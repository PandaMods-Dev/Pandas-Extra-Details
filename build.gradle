import groovy.json.JsonSlurper
import groovy.json.JsonBuilder

plugins {
	id "java"
	id "architectury-plugin" version "3.4-SNAPSHOT"
	id "dev.architectury.loom" version "1.7-SNAPSHOT" apply false
	id "com.github.johnrengelman.shadow" version "8.1.1" apply false
	id "systems.manifold.manifold-gradle-plugin" version "0.0.2-alpha"
	id "me.modmuss50.mod-publish-plugin" version "0.5.1"
}

def writeBuildGradlePredefine(List<String> AvailableVersion, int versionIndex) {
	StringBuilder sb = new StringBuilder()

	sb.append("# DON'T TOUCH THIS FILE, This is handled by the build script\n")

	for (int i = 0; i < AvailableVersion.size(); i++) {
		String versionString = AvailableVersion[i].replace(".", "_")
		sb.append("MC_" + versionString + "=" + i.toString() + "\n")
		ext.set("MC_" + versionString, i.toString())

		if (versionIndex == i) {
			sb.append("MC_VER=" + i.toString() + "\n")
			ext.set("MC_VER", i.toString())
		}
	}

	new File(projectDir, "build.properties").text = sb.toString()
}

project.gradle.ext.getProperties().each { prop ->
	ext.set(prop.key, prop.value)
}

writeBuildGradlePredefine(availableVersions, versionIndex)

architectury {
	minecraft = minecraft_version
}

allprojects {
	group = maven_group
	version = "${mod_version}-${minecraft_version}"
}

subprojects {
	apply plugin: "com.github.johnrengelman.shadow"
	apply plugin: "dev.architectury.loom"
	apply plugin: "architectury-plugin"
	apply plugin: "maven-publish"

	base {
		archivesName = "${archives_name}-${project.name}"
	}

	configurations {
		includeJar
		include.extendsFrom includeJar
		implementation.extendsFrom includeJar

		includeModJar
		include.extendsFrom includeModJar
		modImplementation.extendsFrom includeModJar
	}

	repositories {
		maven {
			name = "ParchmentMC"
			url = "https://maven.parchmentmc.org"
		}
		exclusiveContent {
			forRepository {
				maven {
					name = "Modrinth"
					url = "https://api.modrinth.com/maven"
				}
			}
			filter {
				includeGroup "maven.modrinth"
			}
		}
		mavenLocal()
	}

	dependencies {
		minecraft "com.mojang:minecraft:${minecraft_version}"
		mappings loom.layered() {
			officialMojangMappings()
			parchment "org.parchmentmc.data:parchment-${parchment_version}@zip"
		}

		annotationProcessor("systems.manifold:manifold-preprocessor:${manifold_version}")

		implementation platform("org.lwjgl:lwjgl-bom:${lwjgl_version}")

		implementation("org.lwjgl:lwjgl")
		implementation("org.lwjgl:lwjgl-assimp")

		runtimeOnly("org.lwjgl:lwjgl::${lwjgl_natives}")
		runtimeOnly("org.lwjgl:lwjgl-assimp::${lwjgl_natives}")
	}

	processResources {
		def replaceProperties = [
				java_version                : java_version,
				version                     : mod_version,
				id                          : archives_name,
				name                        : mod_name,
				description                 : mod_description,

				compatible_fabricmc_versions: compatible_fabricmc_versions,
				compatible_forgemc_versions : compatible_forgemc_versions
		]

		inputs.properties replaceProperties
		filesMatching(["fabric.mod.json", "META-INF/mods.toml", "META-INF/neoforge.mods.toml"]) {
			expand replaceProperties
		}
	}

	// Fix for Access widener reference not getting removed from architectury.common.json when build
	tasks.register("removeAWfromArchitecturyJson") {
		doLast {
			def jsonFile = file("$buildDir/resources/main/architectury.common.json")

			if (jsonFile.exists()) {
				def jsonContent = new JsonSlurper().parse(jsonFile)

				jsonContent.remove("accessWidener")
				jsonFile.write(new JsonBuilder(jsonContent).toPrettyString())
			}
		}
	}

	jar {
		dependsOn removeAWfromArchitecturyJson
	}

	tasks.withType(JavaCompile).configureEach {
		options.encoding = "UTF-8"
		options.release = java_version as Integer
		options.compilerArgs += ["-Xplugin:Manifold"]
	}

	java {
		withSourcesJar()
	}

	publishing {
		publications {
			mavenJava(MavenPublication) {
				groupId = maven_group
				artifactId = "${archives_name}-${project.name}"
				version = project.version
				from components.java
			}
		}

		repositories {
		}
	}
}

publishMods {
	var using_ranged_game_version = rootProject.hasProperty("latest_supported_game_version")

	dryRun = Boolean.parseBoolean(is_dry_run)

	version = mod_version
	type = BETA
	changelog = file("Changelog.md").text

	var supported_version_str = using_ranged_game_version ?
			"${supported_game_version}-${latest_supported_game_version}" :
			supported_game_version

	discord {
		webhookUrl = providers.environmentVariable("DISCORD_WEBHOOK")
		dryRunWebhookUrl = providers.environmentVariable("DISCORD_WEBHOOK_DRY_RUN")
		username = "Mod Release"
		avatarUrl = "https://avatars.githubusercontent.com/u/70108603?v=4"
		content = changelog.map { "# ${mod_name} ${mod_version} Release for ${supported_version_str} \n" + it + "\n<@&${pinged_discord_role_id}>" }
	}

	def curseforgeOptions = curseforgeOptions {
		accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
		projectId = curseforge_project_id

		if (using_ranged_game_version)
			minecraftVersionRange {
				start = supported_game_version
				end = latest_supported_game_version
			}
		else
			minecraftVersions.add(supported_game_version)

		javaVersions.add(JavaVersion.toVersion(java_version))

		clientRequired = true
		serverRequired = true

		projectSlug = curseforge_project_slug

		if (rootProject.hasProperty("required_curseforge_mods"))
			requires(required_curseforge_mods.split(","))
	}

	def modrinthOptions = modrinthOptions {
		accessToken = providers.environmentVariable("MODRINTH_API_KEY")
		projectId = modrinth_project_id

		if (using_ranged_game_version)
			minecraftVersionRange {
				start = supported_game_version
				end = latest_supported_game_version
			}
		else
			minecraftVersions.add(supported_game_version)

		if (rootProject.hasProperty("required_modrinth_mods"))
			requires(required_modrinth_mods.split(","))
	}

	def fabricOptions = publishOptions {
		file = project(":fabric").remapJar.archiveFile
		modLoaders.add("fabric")
		displayName = "[Fabric ${supported_version_str}] ${mod_version}"
	}

	def forgeOptions = publishOptions {
		file = project(":forge").remapJar.archiveFile
		modLoaders.add("forge")
		displayName = "[Forge ${supported_version_str}] ${mod_version}"
	}

	def neoForgeOptions = publishOptions {
		file = project(":neoforge").remapJar.archiveFile
		modLoaders.add("neoforge")
		displayName = "[NeoForge ${supported_version_str}] ${mod_version}"
	}

	if (findProject(":fabric")) {
		curseforge("curseforgeFabric") {
			from(curseforgeOptions, fabricOptions)

			announcementTitle = "Download for Fabric ${supported_version_str} from CurseForge"

			if (rootProject.hasProperty("required_fabric_mods"))
				requires(required_fabric_mods.split(","))
		}

		modrinth("modrinthFabric") {
			from(modrinthOptions, fabricOptions)

			announcementTitle = "Download for Fabric ${supported_version_str} from Modrinth"

			if (rootProject.hasProperty("required_fabric_mods"))
				requires(required_fabric_mods.split(","))
		}
	}

	if (findProject(":forge")) {
		curseforge("curseforgeForge") {
			from(curseforgeOptions, forgeOptions)

			announcementTitle = "Download for Forge ${supported_version_str} from CurseForge"

			if (rootProject.hasProperty("required_forge_mods"))
				requires(required_forge_mods.split(","))
		}

		modrinth("modrinthForge") {
			from(modrinthOptions, forgeOptions)

			announcementTitle = "Download for Forge ${supported_version_str} from Modrinth"

			if (rootProject.hasProperty("required_forge_mods"))
				requires(required_forge_mods.split(","))
		}
	}

	if (findProject(":neoforge")) {
		curseforge("curseforgeNeoForge") {
			from(curseforgeOptions, neoForgeOptions)

			announcementTitle = "Download for NeoForge ${supported_version_str} from CurseForge"

			if (rootProject.hasProperty("required_neoforge_mods"))
				requires(required_neoforge_mods.split(","))
		}

		modrinth("modrinthNeoForge") {
			from(modrinthOptions, neoForgeOptions)

			announcementTitle = "Download for NeoForge ${supported_version_str} from Modrinth"

			if (rootProject.hasProperty("required_neoforge_mods"))
				requires(required_neoforge_mods.split(","))
		}
	}

	github {
		accessToken = providers.environmentVariable("GITHUB_API_KEY")
		repository = github_repo
		commitish = "main"
		tagName = "release/${mod_version}-${supported_version_str}"

		file = project(":common").remapJar.archiveFile

		if (findProject(":fabric")) {
			modLoaders.add("fabric")
			additionalFiles.from(project(":fabric").remapJar.archiveFile)
		}
		if (findProject(":forge")) {
			modLoaders.add("forge")
			additionalFiles.from(project(":forge").remapJar.archiveFile)
		}
		if (findProject(":neoforge")) {
			modLoaders.add("neoforge")
			additionalFiles.from(project(":neoforge").remapJar.archiveFile)
		}
	}
}